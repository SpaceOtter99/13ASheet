{% extends 'base.html' %}
{% block title %}{{ character.name }}{% endblock %}
{% block content %}
  <body>
    <h1>{{ character.name }}</h1>

    <table id="stats">
      <thead>
        <tr>
          {% for stat in data.stats %}
            <th>{{ stat }}</th>
          {% endfor %}
        </tr>
      </thead>
      <tbody>
        <tr>
          {% for stat in data.stats %}
          <td>
            <input
              type="number" min="0"
              id="stat-{{ stat }}"
              value="{{ character.stats[stat] }}"
            >
          </td>
          {% endfor %}
        </tr>
        <tr>
          {% for stat in data.stats %}
            <td id="mod-{{ stat }}">{{ character.modifier(stat) }}</td>
          {% endfor %}
        </tr>
      </tbody>
      </tbody>
    </table>

    

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const stats       = {{ data.stats|tojson}};
        const name        = "{{ character.name }}";
        let timer         = null;
        // clone current stats
        let updatedStats  = {};

        // send the full updatedStats to the server
        function doSave(options = {}) {
          fetch(`{{ url_for('update_character', name=character.name) }}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            keepalive: options.keepalive || false,
            body: JSON.stringify({ stats: updatedStats })
          })
          .then(r => r.json())
          .then(json => {
            if (json.status !== 'ok') {
              console.warn('Save failed', json);
            }
          })
          .catch(err => console.error('Save error', err));
        }

        // schedule a debounced save in 5s
        function scheduleSave() {
          clearTimeout(timer);
          timer = setTimeout(() => doSave(), 5000);
        }

        // flush immediately (for unload)
        function flushSave() {
          if (timer !== null) {
            clearTimeout(timer);
            doSave({ keepalive: true });
            timer = null;
          }
        }

        // bind inputs
        stats.forEach(stat => {
          const input = document.getElementById(`stat-${stat}`);
          input.addEventListener('input', () => {
            const val = parseInt(input.value, 10) || 0;
            updatedStats[stat] = val;
            // immediate modifier update
            document.getElementById(`mod-${stat}`)
              .textContent = Math.floor((val - 10) / 2);
            // debounce the save
            scheduleSave();
          });
        });

        // on page unload or tab close, flush pending save
        window.addEventListener('beforeunload', flushSave);
        // also handle visibilitychange (e.g. mobile switch)
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') {
            flushSave();
          }
        });
      });
    </script>
  </body>
{% endblock %}